package com.enterprise.portfolio.userservice.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import com.enterprise.portfolio.userservice.service.CacheService;
import com.enterprise.portfolio.userservice.service.KafkaEventService;
import com.enterprise.portfolio.userservice.service.UserService;
import com.enterprise.portfolio.userservice.dto.UserRegistrationRequest;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;

import java.time.Duration;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.atomic.AtomicLong;

@RestController
@RequestMapping("/api/v1/demo")
@Tag(name = "Live Java Demo", description = "Pure Java demonstration of Kafka and Redis functionality")
public class JavaDemoController {

    private final CacheService cacheService;
    private final KafkaEventService kafkaEventService;
    private final UserService userService;
    
    // Demo counters
    private final AtomicLong demoCounter = new AtomicLong(1);
    private final AtomicLong redisTests = new AtomicLong(0);
    private final AtomicLong kafkaTests = new AtomicLong(0);

    @Autowired
    public JavaDemoController(CacheService cacheService, 
                             KafkaEventService kafkaEventService,
                             UserService userService) {
        this.cacheService = cacheService;
        this.kafkaEventService = kafkaEventService;
        this.userService = userService;
    }

    @GetMapping("/live-proof")
    @Operation(summary = "Live proof that Kafka and Redis are working", 
               description = "Demonstrates real-time operations on both systems")
    public Mono<Map<String, Object>> getLiveProof() {
        return Mono.fromCallable(() -> {
            Map<String, Object> proof = new HashMap<>();
            proof.put("demonstration", "JAVA_LIVE_DEMO");
            proof.put("timestamp", LocalDateTime.now().toString());
            proof.put("demo_session", demoCounter.get());
            proof.put("total_redis_tests", redisTests.get());
            proof.put("total_kafka_tests", kafkaTests.get());
            proof.put("message", "This response is generated by pure Java Spring Boot WebFlux");
            proof.put("technologies", Map.of(
                "backend", "Java 21 + Spring Boot 3.x + WebFlux",
                "caching", "Redis with Lettuce reactive driver",
                "messaging", "Apache Kafka with Spring Kafka",
                "database", "PostgreSQL with R2DBC",
                "monitoring", "Pure Java implementation"
            ));
            return proof;
        });
    }

    @PostMapping("/redis-live-test")
    @Operation(summary = "Live Redis caching test", 
               description = "Performs real Redis operations you can watch")
    public Mono<Map<String, Object>> testRedisLive() {
        long testId = redisTests.incrementAndGet();
        String testKey = "java-demo-" + testId + "-" + System.currentTimeMillis();
        String testData = "Java-generated test data #" + testId + " at " + LocalDateTime.now();
        
        return cacheService.cacheUserProfile(testKey, testData)
            .then(cacheService.getCachedUserProfile(testKey))
            .map(cachedData -> {
                Map<String, Object> result = new HashMap<>();
                result.put("status", "REDIS_LIVE_TEST_SUCCESS");
                result.put("test_id", testId);
                result.put("operation", "CACHE_SET_AND_GET");
                result.put("key", testKey);
                result.put("original_data", testData);
                result.put("cached_data", cachedData);
                result.put("cache_validation", testData.equals(cachedData.toString()));
                result.put("timestamp", System.currentTimeMillis());
                result.put("message", "✅ Redis caching verified - Java stored and retrieved data successfully");
                return result;
            })
            .doOnError(error -> error.printStackTrace());
    }

    @PostMapping("/kafka-live-test")
    @Operation(summary = "Live Kafka messaging test", 
               description = "Publishes real Kafka events you can monitor")
    public Mono<Map<String, Object>> testKafkaLive() {
        long testId = kafkaTests.incrementAndGet();
        String userId = "java-demo-user-" + testId;
        String message = "Live Java Kafka test event #" + testId + " at " + LocalDateTime.now();
        
        return kafkaEventService.publishNotificationEvent(userId, message, "java_live_demo")
            .map(result -> {
                Map<String, Object> response = new HashMap<>();
                response.put("status", "KAFKA_LIVE_TEST_SUCCESS");
                response.put("test_id", testId);
                response.put("operation", "EVENT_PUBLISHED");
                response.put("topic", result.getRecordMetadata().topic());
                response.put("partition", result.getRecordMetadata().partition());
                response.put("offset", result.getRecordMetadata().offset());
                response.put("user_id", userId);
                response.put("message", message);
                response.put("timestamp", System.currentTimeMillis());
                response.put("kafka_proof", "✅ Kafka event published - Message sent to topic successfully via Java");
                return response;
            })
            .doOnError(error -> error.printStackTrace());
    }

    @PostMapping("/full-integration-demo")
    @Operation(summary = "Full integration demonstration", 
               description = "Tests both Redis and Kafka with real user operations")
    public Mono<Map<String, Object>> fullIntegrationDemo() {
        long demoId = demoCounter.incrementAndGet();
        
        // Create test user registration
        UserRegistrationRequest demoUser = new UserRegistrationRequest(
            "javademo" + demoId,
            "javademo" + demoId + "@enterprise-java.com",
            "JavaDemo123!",
            "Java",
            "Demo" + demoId
        );
        
        return userService.registerUser(demoUser)
            .flatMap(registeredUser -> {
                // Test Redis caching with user data
                String cacheKey = "demo-user-" + registeredUser.id();
                return cacheService.cacheUserProfile(cacheKey, registeredUser)
                    .then(cacheService.getCachedUserProfile(cacheKey))
                    .zipWith(
                        // Test Kafka events
                        kafkaEventService.publishNotificationEvent(
                            registeredUser.id().toString(),
                            "Integration demo completed for user " + registeredUser.username(),
                            "integration_demo"
                        )
                    )
                    .map(tuple -> {
                        Map<String, Object> result = new HashMap<>();
                        result.put("status", "FULL_INTEGRATION_SUCCESS");
                        result.put("demo_id", demoId);
                        result.put("user_created", registeredUser);
                        result.put("redis_cached", tuple.getT1() != null);
                        result.put("kafka_published", tuple.getT2() != null);
                        result.put("timestamp", System.currentTimeMillis());
                        result.put("proof", Map.of(
                            "database", "✅ User stored in PostgreSQL via R2DBC",
                            "redis", "✅ User data cached in Redis via Java",
                            "kafka", "✅ User event published to Kafka via Java",
                            "integration", "✅ All systems working together"
                        ));
                        return result;
                    });
            })
            .doOnError(error -> error.printStackTrace());
    }

    @GetMapping(value = "/real-time-stats", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    @Operation(summary = "Real-time statistics stream", 
               description = "Server-Sent Events showing live system activity")
    public Flux<Map<String, Object>> getRealTimeStats() {
        return Flux.interval(Duration.ofSeconds(2))
            .map(tick -> {
                Map<String, Object> stats = new HashMap<>();
                stats.put("timestamp", LocalDateTime.now().toString());
                stats.put("demo_sessions", demoCounter.get());
                stats.put("redis_tests_completed", redisTests.get());
                stats.put("kafka_tests_completed", kafkaTests.get());
                stats.put("uptime_seconds", tick * 2);
                stats.put("java_memory_used_mb", 
                    (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) / 1024 / 1024);
                stats.put("status", "JAVA_MONITORING_ACTIVE");
                return stats;
            });
    }

    @PostMapping("/stress-test")
    @Operation(summary = "Stress test both systems", 
               description = "Performs multiple operations to demonstrate system performance")
    public Flux<Map<String, Object>> stressTest(@RequestParam(defaultValue = "20") int operations) {
        return Flux.range(1, operations)
            .flatMap(i -> {
                // Alternate between Redis and Kafka tests
                if (i % 2 == 0) {
                    return testRedisLive()
                        .map(result -> {
                            result.put("stress_test_operation", i);
                            result.put("operation_type", "REDIS_CACHE");
                            return result;
                        });
                } else {
                    return testKafkaLive()
                        .map(result -> {
                            result.put("stress_test_operation", i);
                            result.put("operation_type", "KAFKA_EVENT");
                            return result;
                        });
                }
            })
            .delayElements(Duration.ofMillis(500)); // 500ms delay between operations
    }

    @GetMapping("/system-overview")
    @Operation(summary = "Complete system overview", 
               description = "Comprehensive view of all integrated systems")
    public Mono<Map<String, Object>> getSystemOverview() {
        return Mono.zip(
            cacheService.ping(),
            kafkaEventService.testKafkaConnection()
        )
        .map(tuple -> {
            Map<String, Object> overview = new HashMap<>();
            overview.put("system_name", "Enterprise Java Portfolio");
            overview.put("architecture", "Event-driven microservices with reactive streams");
            overview.put("timestamp", LocalDateTime.now().toString());
            
            // System components status
            Map<String, Object> components = new HashMap<>();
            components.put("spring_boot", Map.of(
                "status", "ACTIVE",
                "version", "3.x",
                "profile", "Reactive WebFlux"
            ));
            components.put("redis", Map.of(
                "status", tuple.getT1().contains("successful") ? "CONNECTED" : "DISCONNECTED",
                "driver", "Lettuce Reactive",
                "purpose", "Caching user profiles and search results"
            ));
            components.put("kafka", Map.of(
                "status", tuple.getT2().contains("successful") ? "CONNECTED" : "DISCONNECTED",
                "client", "Spring Kafka",
                "purpose", "Event streaming and notifications"
            ));
            components.put("postgresql", Map.of(
                "status", "CONNECTED",
                "driver", "R2DBC Reactive",
                "purpose", "Primary data storage"
            ));
            
            overview.put("components", components);
            overview.put("demo_statistics", Map.of(
                "total_demo_sessions", demoCounter.get(),
                "redis_tests_performed", redisTests.get(),
                "kafka_tests_performed", kafkaTests.get()
            ));
            
            return overview;
        });
    }

    @DeleteMapping("/reset-demo-counters")
    @Operation(summary = "Reset demo counters", description = "Reset all demo statistics")
    public Mono<Map<String, Object>> resetDemoCounters() {
        demoCounter.set(1);
        redisTests.set(0);
        kafkaTests.set(0);
        
        return Mono.just(Map.of(
            "status", "COUNTERS_RESET",
            "message", "All demo counters reset to initial state",
            "timestamp", System.currentTimeMillis()
        ));
    }
}